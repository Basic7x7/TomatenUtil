// @txsinfo();
package de.tomatengames.util.function;
##
:inline=§

extern final int n;
extern final object out;

final string[] genericTypes = new string[n+1];
genericTypes[0] = !out.prim && "T";
for (int i = 0; i < n; i++) {
	genericTypes[i+1] = toChar(`A`+i);
}
final string gen = join(", ", genericTypes);
final string generic = gen.length > 0 && "<"::gen::">";

final string Function = "Ref"::n::"To"::out.name::"Function";
##

/**
 * A function that accepts §n; generic input parameter§n!=1&&"s"; and returns §out.a; {@code §out.docName;}.
 * 
 # if (!out.prim) {
 * @param <T> The return type.
 * 
 # }
 * @author Basic7x7
 * @version
 * 2023-04-11 last modified<br>
 * 2023-02-19 created
 * @since 1.2
 */
@FunctionalInterface
public interface §Function;§generic; {
	
	/**
	 * Applies the function.
	 # for (int i = 0; i < n; i++) {
	 * @param §toChar(`a`+i); An argument.
	 # }
	 * @return The result.
	 */
	public §out.java; apply(##
			for (int i = 0; i < n; i++) {
				string type = toChar(`A`+i);
				string name = lowercase(type);
				##§i>0 && ", ";§type; §name;##
			}
			##);
##

if (out.java == "boolean") {
	string[] argNames = new string[n];
	for (int i = 0; i < n; i++) {
		argNames[i] = toChar(`a`+i);
	}
	string args = join(", ", argNames);
	##
	
	
	/**
	 * Returns a §Function; that represents {@code !this.apply(...)}.
	 * @return The logical negation of this function.
	 */
	public default §Function;§generic; negate() {
		return (§args;) -> !this.apply(§args;);
	}
	
	/**
	 * Returns a §Function; that represents {@code !func.apply(...)}.
	 * @param func The function to negate. Must not be {@code null}.
	 * @return The logical negation of the specified function.
	 * @throws NullPointerException If the specified function is {@code null}.
	 */
	public static §?generic; §Function;§generic; not(§Function;§generic; func) {
		return func.negate();
	}
	##
}
##
	
}